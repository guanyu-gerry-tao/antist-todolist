import { create, div, filter, style, text } from 'motion/react-client';
import '../App.css'
import './Task.css'
import type { TaskType, Actions, States, TaskId } from '../utils/type.ts'
import { Draggable } from '@hello-pangea/dnd';
import React, { useRef, useEffect } from 'react';
import { useAppContext } from './AppContext.tsx';
import { createBackup, createBulkPayload, restoreBackup } from '../utils/utils.ts';

/**
 * This function is used to get the style of the task when it is being dragged
 * @param style - The current style of the task
 * @param snapshot - Callback function from Draggable component
 * @returns style object to input in the Draggable component
 */
function getStyle(style: any, snapshot: any) {
  if (snapshot.isDragging) {
    return {
      ...style,
      boxShadow: `rgba(114, 114, 114, 0.5) 0px 5px 10px 5px`,
      opacity: 0.5,
    }
  }
  return style;
}

// TODO: refine style when dropping task 


/**
 * This component represents a single task (a task card) in the task list.
 * @param taskInfo - The information of the task, defined in App.tsx.
 * @param actions - The object containing actions, defined in App.tsx.
 */
function Task({ task, tasks, }: { task: [TaskId, TaskType], tasks: [TaskId, TaskType][], }) {

  // Use the AppContext to access the global state and actions
  const { states, actions, setStates } = useAppContext();

  let tempValue = task[1].title; // Temporary variable to store the current value of the input field

  /**
   * Handle click event on the task title, saves the current value of the input field.
   * This is used to restore the value when the Escape key is pressed.
   * @param e - The mouse event, auto-generated by React.
   */
  const handleClickTitle = (e: React.MouseEvent<HTMLTextAreaElement>) => {
    tempValue = e.currentTarget.value; // Store the current value of the input field
  };

  /**
   * Handle keyboard events on the task title input field.
   * This function updates the task title when Enter is pressed, restores the previous value when Escape is pressed,
   * and deletes the task when Backspace or Delete is pressed.
   * @param e - The keyboard event, auto-generated by React.
   */
  const handleTitleKeyboard = async (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
    if (e.key === 'Enter') {
      e.preventDefault(); // Prevent default Enter key behavior (adding a new line)
      
      const bulkPayload = createBulkPayload();
      const backup = createBackup(states, bulkPayload);
      actions.updateTasks([{ id: task[0], updatedFields: { title: e.currentTarget.value } }], backup);
      try {
        await fetch('/api/tasks', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(backup),
        });
      } catch (error) {
        console.error('Error fetching tasks:', error);
        // If the request fails, restore the previous state from the backup
        restoreBackup(setStates, backup);
      };

      e.currentTarget.blur(); // Remove focus from the input field
      console.log(`update title: ${e.currentTarget.title}`)
    }
    if (e.key === 'Escape' && e.currentTarget.value !== '') {
      // Handle Escape key press logic here
      e.currentTarget.value = tempValue; // Restore the previous value
      e.currentTarget.blur(); // Remove focus from the input field
    }
  };

  /**
   * Handle focus lost event on the task title input field.
   * This function deletes the task if the title is empty, or updates the title if it has changed.
   * @param e - The focus event, auto-generated by React.
   */
  const handleTitleLostFocus = async (e: React.FocusEvent<HTMLTextAreaElement>) => {
    if (e.currentTarget.value !== task[1].title) {

      const bulkPayload = createBulkPayload();
      const backup = createBackup(states, bulkPayload);
      actions.updateTasks([{ id: task[0], updatedFields: { title: e.currentTarget.value } }], backup);
      try {
        await fetch('/api/tasks', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(backup),
        });
      } catch (error) {
        console.error('Error fetching tasks:', error);
        // If the request fails, restore the previous state from the backup
        restoreBackup(setStates, backup);
      };
      console.log(`Title updated to: ${e.currentTarget.value}`);
    }
  };

  /**
   * Handle focus lost event on the task description input field.
   * This function updates the task description if it has changed.
   * @param e - The focus event, auto-generated by React.
   */
  const handleDescLostFocus = async (e: React.FocusEvent<HTMLTextAreaElement>) => {
    if (e.currentTarget.value !== task[1].description) {
      const bulkPayload = createBulkPayload();
      const backup = createBackup(states, bulkPayload);
      actions.updateTasks([{ id: task[0], updatedFields: { description: e.currentTarget.value } }], backup);
      try {
        await fetch('/api/tasks', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(backup),
        });
      } catch (error) {
        console.error('Error fetching tasks:', error);
        // If the request fails, restore the previous state from the backup
        restoreBackup(setStates, backup);
      };
      console.log(`Description updated to: ${e.currentTarget.value}`);
    }
  }

  /**
   * Handle keyboard events on the task description input field.
   * This function updates the task description when Enter is pressed, restores the previous value when Escape is pressed,
   * and removes focus from the textarea when Enter is pressed without Shift.
   * @param e - The keyboard event, auto-generated by React.
   */
  const handleDescKeyboard = async (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault(); // Prevent default Enter key behavior (adding a new line)
      e.currentTarget.blur(); // Remove focus from the textarea
      console.log(`Description updated to: ${e.currentTarget.value}`);

      const bulkPayload = createBulkPayload();
      const backup = createBackup(states, bulkPayload);
      actions.updateTasks([{ id: task[0], updatedFields: { description: e.currentTarget.value } }], backup);
      try {
        await fetch('/api/tasks', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(backup),
        });
      } catch (error) {
        console.error('Error fetching tasks:', error);
        // If the request fails, restore the previous state from the backup
        restoreBackup(setStates, backup);
      };
    }
    if (e.key === 'Escape' && e.currentTarget.value !== '') {
      // Handle Escape key press logic here
      e.currentTarget.value = task[1].description || ''; // Restore the previous value
      e.currentTarget.blur(); // Remove focus from the textarea
      if (textAreaRefDesc.current) {
        textAreaRefDesc.current!.style.height = 'auto'; // Reset height to auto
        textAreaRefDesc.current.style.height = textAreaRefDesc.current.scrollHeight + 'px'; // Set height to scrollHeight
      }
    }
  }

  const handleDeleteButton = async (e: React.MouseEvent<HTMLDivElement>) => {
    e.stopPropagation(); // Prevent the click event from propagating to the parent div
    if (task[1].status === 'deleted') {
      if (window.confirm(`By double deleting task: ${task[1].title}, you will permanently delete it. Are you sure?`)) {
        const bulkPayload = createBulkPayload();
        actions.hardDeleteTasks([task[0]], bulkPayload); // Permanently delete the task
        try {
          await fetch('/api/tasks', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(bulkPayload),
          });
        } catch (error) {
          console.error('Error fetching tasks:', error);
          // If the request fails, restore the previous state from the backup
          restoreBackup(setStates, bulkPayload);
        };
      };
    } else {
      const bulkPayload = createBulkPayload();
      const backup = createBackup(states, bulkPayload);
      actions.moveTasks([task[0]], 'deleted', 'end', backup); // Move the task to the end of the deleted list
      try {
        await fetch('/api/tasks', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(backup),
        });
      } catch (error) {
        console.error('Error fetching tasks:', error);
        // If the request fails, restore the previous state from the backup
        restoreBackup(setStates, backup);
      };
    };
  };

  const handleCompleteButton = async (e: React.MouseEvent<HTMLDivElement>) => {
    e.stopPropagation(); // Prevent the click event from propagating to the parent div
    if (task[1].status === 'completed' || task[1].status === 'deleted') {
      // for deleted/completed tasks, there shouldn't be a complete button, so we don't need to handle this case.
      console.warn(`Task with id ${task[0]} is deleted/completed, cannot complete it.`);
    } else {
      const bulkPayload = createBulkPayload();
      const backup = createBackup(states, bulkPayload);
      actions.moveTasks([task[0]], 'completed', 'end', backup); // Move the task to the end of the completed list
      try {
        await fetch('/api/tasks', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(backup),
        });
      } catch (error) {
        console.error('Error fetching tasks:', error);
        // If the request fails, restore the previous state from the backup
        restoreBackup(setStates, backup);
      }
      console.log(`Task ${task[0]} completed: ${task[1].title}`); // Log the completion of the task
    }
  }
  
  /**
   * Handles the restore button click event.
   * @param e - The mouse event, auto-generated by React.
   */
  const handleRestoreButton = async (e: React.MouseEvent<HTMLDivElement>) => {
    const bulkPayload = createBulkPayload();
    const backup = createBackup(states, bulkPayload);
    e.stopPropagation(); // Prevent the click event from propagating to the parent div
    actions.moveTasks([task[0]], task[1].previousStatus, 'end', backup); // Move the task to the end of the todo list
    try {
      await fetch('/api/tasks', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(backup),
      });
    } catch (error) {
      console.error('Error fetching tasks:', error);
      // If the request fails, restore the previous state from the backup
      restoreBackup(setStates, backup);
    }
  }

  /**
   * Handles changes to the due date input field.
   * @param e - The change event, auto-generated by React.
   */
  const handleDueDateChange = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const bulkPayload = createBulkPayload();
    const backup = createBackup(states, bulkPayload);
    if (!e.currentTarget.value) {
      actions.updateTasks([{ id: task[0], updatedFields: { dueDate: undefined } }], bulkPayload); // Clear the due date
    } else {
      actions.updateTasks([{ id: task[0], updatedFields: { dueDate: new Date(e.currentTarget.value) } }], bulkPayload);
      console.log(`Due date updated to: ${e.currentTarget.value}`);
    }

    try {
      await fetch('/api/tasks', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(backup),
      });
    } catch (error) {
      console.error('Error fetching tasks:', error);
      // If the request fails, restore the previous state from the backup
      restoreBackup(setStates, backup);
    }
  }

  const textAreaRefDesc = useRef<HTMLTextAreaElement>(null);
  const textAreaRefTitle = useRef<HTMLTextAreaElement>(null);

  // Adjust the height of the text area based on its content
  // This effect runs whenever the task title or description changes
  // The first = '0px' set the height to minimum height, then set it to scrollHeight to ensure it fits the content
  useEffect(() => {
    if (textAreaRefDesc.current) {
      textAreaRefDesc.current.style.height = '0px'; // Reset height to minimum height, ensure it was smaller and then get larger.
      textAreaRefDesc.current.style.height = textAreaRefDesc.current.scrollHeight + 'px'; // Set height to scrollHeight.
    }
  }, [task[1].title, task[1].description]); // This effect runs whenever the task title or description changes

  // Adjust the height of the second text area (task title) based on its content
  useEffect(() => {
    if (textAreaRefTitle.current) {
      textAreaRefTitle.current.style.height = '0px'; // Reset height to minimum height, ensure it was smaller and then get larger.
      textAreaRefTitle.current.style.height = textAreaRefTitle.current.scrollHeight + 'px'; // Set height to scrollHeight.
    }
  }, [task[1].title]); // This effect runs whenever the task title changes

  // Note: the Draggable component from @hello-pangea/dnd requires a unique draggableId for each task.
  // The setup below is specially for the draggable task component.
  // id: it should be unique and match the taskInfo.id, which is already unique. Specially required by Draggable component.
  // ref: it is used to get the reference of the task element for dragging. Specially Required by Draggable component.
  // ...provided.draggableProps: these are the props required by the Draggable component to make the task draggable.
  // ...provided.dragHandleProps: these are the props required by the Draggable component to make the <div> draggable.
  // style: this is used to apply the draggable styles to the task element. See getStyle function above.
  return (
    <Draggable draggableId={task[0]} index={tasks.indexOf(task)}>
      {
        (provided, snapshot) => (
          <div
            className={`card`}
            id={task[0]}
            ref={provided.innerRef}
            {...provided.draggableProps}
            {...provided.dragHandleProps}
            style={{
              ...getStyle(provided.draggableProps.style, snapshot),
            }}
          >

            <div className='taskDragHandler'></div>

            <div className='cardContent'>
              <textarea
                className='taskTitle'
                placeholder='Add a title...'
                defaultValue={task[1].title}
                ref={textAreaRefTitle}
                onChange={(e) => {
                  e.currentTarget.style.height = '0px';
                  e.currentTarget.style.height = e.currentTarget.scrollHeight + 'px';
                }}
                onClick={handleClickTitle}
                onKeyDown={handleTitleKeyboard}
                onBlur={handleTitleLostFocus} />

              <textarea
                className='taskDesc'
                defaultValue={task[1].description}
                placeholder='Add a description...'
                ref={textAreaRefDesc}
                onChange={(e) => {
                  e.currentTarget.style.height = '0px';
                  e.currentTarget.style.height = e.currentTarget.scrollHeight + 'px';
                }}
                onKeyDown={handleDescKeyboard}
                onBlur={handleDescLostFocus}
              />

              <input type='date'
                className='taskDueDate'
                defaultValue={task[1].dueDate ? new Date(task[1].dueDate).toISOString().slice(0, 10) : undefined}
                onChange={handleDueDateChange}
                style={{
                  color: task[1].dueDate && task[1].dueDate < new Date() ? 'red' : '',
                  fontWeight: task[1].dueDate && task[1].dueDate < new Date() ? 'normal' : '',
                  opacity: task[1].dueDate && task[1].dueDate < new Date() ? '1' : ''
                }}
              />

              {/* TODO: add subtasks function: click to drop down subtasks, subtasks can be added, deleted, updated, dragged */}

            </div>
            <div className="deleteTaskButton"
              style={{
                opacity: states.editMode ? 1 : 0,
                visibility: states.editMode ? 'visible' : 'hidden',
                pointerEvents: states.editMode ? 'auto' : 'none'
              }}
              onClick={handleDeleteButton}
            >
            </div>

            {task[1].status !== 'deleted' && task[1].status !== 'completed' && (
              <div className="completeTaskButton"
                style={{
                  opacity: states.editMode ? 1 : 0,
                  visibility: states.editMode ? 'visible' : 'hidden',
                  pointerEvents: states.editMode ? 'auto' : 'none'
                }}
                onClick={handleCompleteButton}
              >
              </div>)
            }


            {(task[1].status === "deleted" || task[1].status === "completed") && (
              <div className="restoreTaskButton"
                style={{
                  opacity: states.editMode ? 1 : 0,
                  visibility: states.editMode ? 'visible' : 'hidden',
                  pointerEvents: states.editMode ? 'auto' : 'none'
                }}
                onClick={handleRestoreButton}
              >
              </div>)
            }
            <p>{task[1].id}</p>
          </div>
        )
      }
    </Draggable>
  )
}

export default Task


